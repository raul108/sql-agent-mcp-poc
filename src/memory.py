"""
Conversation Memory Module

Provides SQLite-based conversation history storage for the SQL Agent.
Enables follow-up questions and context retention across queries.

Features:
- Stores user queries, generated SQL, and results
- Retrieves recent conversation history
- Session-based isolation
- Automatic database initialization
"""

import sqlite3
from datetime import datetime
from typing import List, Dict, Optional
from pathlib import Path


class ConversationMemory:
    """
    SQLite-based conversation history manager.
    
    Stores:
        - User queries (natural language)
        - Generated SQL
        - Query results
        - Timestamps
        - Session IDs
    """
    
    def __init__(self, db_path: str = "conversation_history.db"):
        """
        Initialize conversation memory.
        
        Args:
            db_path: Path to SQLite database file or ":memory:" for in-memory
        """
        self.db_path = db_path
        # For in-memory databases, keep persistent connection
        # (each connect(":memory:") creates a separate database)
        # Use check_same_thread=False for multi-threaded environments (LangGraph)
        self._persistent_conn = None
        if db_path == ":memory:":
            self._persistent_conn = sqlite3.connect(":memory:", check_same_thread=False)
        self._init_database()
    
    def _get_connection(self):
        """Get database connection (persistent for :memory:, new for file)."""
        if self._persistent_conn is not None:
            return self._persistent_conn
        return sqlite3.connect(self.db_path)
    
    def _init_database(self):
        """Create tables if they don't exist."""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS conversations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                session_id TEXT NOT NULL,
                timestamp TEXT NOT NULL,
                user_query TEXT NOT NULL,
                generated_sql TEXT,
                result_summary TEXT,
                is_successful BOOLEAN DEFAULT 1
            )
        """)
        
        conn.commit()
        # Only close if it's a file-based connection
        if self._persistent_conn is None:
            conn.close()
    
    def add_interaction(
        self,
        session_id: str,
        user_query: str,
        generated_sql: Optional[str] = None,
        result_summary: Optional[str] = None,
        is_successful: bool = True
    ):
        """
        Store a conversation interaction.
        
        Args:
            session_id: Unique session identifier
            user_query: User's natural language query
            generated_sql: SQL query generated by agent
            result_summary: Summary of query results
            is_successful: Whether query executed successfully
        """
        conn = self._get_connection()
        cursor = conn.cursor()
        
        timestamp = datetime.now().isoformat()
        
        cursor.execute("""
            INSERT INTO conversations 
            (session_id, timestamp, user_query, generated_sql, result_summary, is_successful)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (session_id, timestamp, user_query, generated_sql, result_summary, is_successful))
        
        conn.commit()
        # Only close if it's a file-based connection
        if self._persistent_conn is None:
            conn.close()
    
    def get_recent_history(
        self,
        session_id: str,
        limit: int = 5
    ) -> List[Dict[str, any]]:
        """
        Retrieve recent conversation history for a session.
        
        Args:
            session_id: Session to retrieve history for
            limit: Maximum number of interactions to retrieve
            
        Returns:
            List of conversation dictionaries (most recent first)
        """
        conn = self._get_connection()
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT * FROM conversations
            WHERE session_id = ?
            ORDER BY timestamp DESC
            LIMIT ?
        """, (session_id, limit))
        
        rows = cursor.fetchall()
        # Only close if it's a file-based connection
        if self._persistent_conn is None:
            conn.close()
        
        # Convert to list of dicts and reverse to chronological order
        history = [dict(row) for row in rows]
        history.reverse()
        
        return history
    
    def format_history_for_context(
        self,
        session_id: str,
        limit: int = 3
    ) -> str:
        """
        Format recent history as context for the LLM.
        
        Args:
            session_id: Session to retrieve history for
            limit: Number of recent interactions to include
            
        Returns:
            Formatted string with conversation history
        """
        history = self.get_recent_history(session_id, limit)
        
        if not history:
            return "No previous conversation history."
        
        formatted = "Recent Conversation History:\n\n"
        
        for i, interaction in enumerate(history, 1):
            formatted += f"{i}. User: {interaction['user_query']}\n"
            if interaction['generated_sql']:
                formatted += f"   SQL: {interaction['generated_sql']}\n"
            if interaction['result_summary']:
                # Truncate long results
                summary = interaction['result_summary']
                if len(summary) > 200:
                    summary = summary[:200] + "..."
                formatted += f"   Result: {summary}\n"
            formatted += "\n"
        
        return formatted
    
    def clear_session(self, session_id: str):
        """
        Clear all history for a specific session.
        
        Args:
            session_id: Session to clear
        """
        conn = self._get_connection()
        cursor = conn.cursor()
        
        cursor.execute("DELETE FROM conversations WHERE session_id = ?", (session_id,))
        
        conn.commit()
        # Only close if it's a file-based connection
        if self._persistent_conn is None:
            conn.close()
    
    def get_session_count(self, session_id: str) -> int:
        """
        Get number of interactions in a session.
        
        Args:
            session_id: Session to count
            
        Returns:
            Number of stored interactions
        """
        conn = self._get_connection()
        cursor = conn.cursor()
        
        cursor.execute(
            "SELECT COUNT(*) FROM conversations WHERE session_id = ?",
            (session_id,)
        )
        
        count = cursor.fetchone()[0]
        # Only close if it's a file-based connection
        if self._persistent_conn is None:
            conn.close()
        
        return count
